(import (chicken condition)
        (srfi 18)
        (srfi 25)
        ncurses)

(define-constant KEY-QUIT #\q)
(define KEY-LEFT  `(#\a #\h ,(integer->char KEY_LEFT)))
(define KEY-RIGHT `(#\d #\l ,(integer->char KEY_RIGHT)))

(define-constant SCR-COLS 40)
(define-constant SCR-ROWS 12)

(define-constant GRID-COLS (- SCR-COLS 2))
(define-constant GRID-ROWS (- SCR-ROWS 1))

(define-constant FPS        60)
(define-constant SLEEP-DRAW (/ 1.0 FPS))
(define-constant SLEEP-LOOP (/ 1.0 FPS))

(define-constant PLAYER-START-X (- (inexact->exact (floor (/ GRID-COLS 2))) 1))
(define-constant PLAYER-START-Y (- GRID-ROWS 1))
(define-constant PLAYER-RADIUS  2)

(define-constant BALL-START-X (- (inexact->exact (floor (/ GRID-COLS 2))) 1))
(define-constant BALL-START-Y (- GRID-ROWS 5))
(define-constant BALL-SPEED   10)
(define-constant STEPS/MOVE   (inexact->exact (round (/ FPS BALL-SPEED))))

(define-constant EMPTY-NUM  0)
(define-constant BLOCK-NUM  1)
(define-constant PLAYER-NUM 2)
(define-constant BALL-NUM   3)

(define-constant EMPTY-CHAR  #\space)
(define-constant BLOCK-CHAR  #\X)
(define-constant PLAYER-CHAR #\-)
(define-constant BALL-CHAR   #\O)

(define-constant DEFAULT-BLOCKS #("                                      "
                                  "   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   "
                                  "   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   "
                                  "   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   "))

(define efloor (compose inexact->exact floor))

(define (end-game state)
  (define win "VICTORY")
  (define loss "DEFEAT")
  (if (eq? state 'win)
      (mvaddstr (efloor (/ SCR-ROWS 2))
                (- (efloor (/ SCR-COLS 2)) (efloor (/ (string-length win) 2)))
                win)
      (mvaddstr (efloor (/ SCR-ROWS 2))
                (- (efloor (/ SCR-COLS 2)) (efloor (/ (string-length loss) 2)))
                loss))
  (refresh)
  (do ((key (getch) (getch)))
      ((eqv? key KEY-QUIT)))
  (endwin)
  (exit))

(define blocks (make-array (shape 0 GRID-COLS 0 GRID-ROWS) #f))
(define block-count 0)

(define (block-ref x y)
  (array-ref blocks x y))

(define (block-set! x y e)
  (array-set! blocks x y e))

(define (load-blocks! lines)
  (do ((y 0 (+ y 1)))
      ((= y (vector-length lines)))
    (let ((line (vector-ref lines y)))
      (do ((x 0 (+ x 1)))
          ((= x (string-length line)))
        (unless (char-whitespace? (string-ref line x))
          (array-set! blocks x y #t)
          (set! block-count (+ block-count 1)))))))

(define (block-destroy! x y)
  (block-set! x y #f)
  (set! block-count (- block-count 1)))

(define player (cons PLAYER-START-X PLAYER-START-Y))

(define (player-x) (car player))
(define (player-y) (cdr player))

(define (player-x-set! x) (set! (car player) x))
(define (player-y-set! y) (set! (cdr player) y))

(define (player-move! dx)
  (cond ((negative? dx) (when (> (player-x) PLAYER-RADIUS)
                          (player-x-set! (+ (player-x) dx))))
        ((positive? dx) (when (< (player-x) (- GRID-COLS PLAYER-RADIUS 1))
                          (player-x-set! (+ (player-x) dx))))))

(define ball (vector BALL-START-X BALL-START-Y 0 1))

(define (ball-x) (vector-ref ball 0))
(define (ball-y) (vector-ref ball 1))

(define (ball-vx) (vector-ref ball 2))
(define (ball-vy) (vector-ref ball 3))

(define (ball-x-set! x) (vector-set! ball 0 x))
(define (ball-y-set! y) (vector-set! ball 1 y))

(define (ball-vx-set! vx) (vector-set! ball 2 vx))
(define (ball-vy-set! vy) (vector-set! ball 3 vy))

(define (ball-invert-vx!) (ball-vx-set! (- (ball-vx))))
(define (ball-invert-vy!) (ball-vy-set! (- (ball-vy))))

(define (handle-oob!)
  (define x (+ (ball-x) (ball-vx)))
  (when (or (< x 0) (>= x GRID-COLS))
    (ball-invert-vx!))
  (when (< (+ (ball-y) (ball-vy)) 0)
    (ball-invert-vy!)))

(define (block-bounce! x y)
  (unless (= x (ball-x)) (ball-invert-vx!))
  (unless (= y (ball-y)) (ball-invert-vy!)))

(define (player-collision? x y)
  (and (= y (- GRID-ROWS 1))
       (<= (abs (- (player-x) (ball-x))) PLAYER-RADIUS)))

(define (player-bounce! x y)
  (ball-vx-set! (cond ((< x (player-x)) -1)
                      ((> x (player-x)) 1)
                      (else 0)))
  (ball-invert-vy!))

(define (ball-update!)
  (handle-oob!)
  (let ((nx (+ (ball-x) (ball-vx)))
        (ny (+ (ball-y) (ball-vy))))
    (cond ((and (block-ref nx (ball-y))
                (block-ref (ball-x) ny))
           (block-destroy! nx (ball-y))
           (block-destroy! (ball-x) ny)
           (block-bounce! nx ny))
          ((block-ref nx (ball-y))
           (block-destroy! nx (ball-y))
           (block-bounce! nx (ball-y)))
          ((block-ref (ball-x) ny)
           (block-destroy! (ball-x) ny)
           (block-bounce! (ball-x) ny))
          ((block-ref nx ny)
           (block-destroy! nx ny)
           (block-bounce! nx ny))
          ((player-collision? nx ny) (player-bounce! nx ny))))
  (handle-oob!)
  (ball-x-set! (+ (ball-x) (ball-vx)))
  (ball-y-set! (+ (ball-y) (ball-vy))))

(define ball-step!
  (let ((step 0))
    (lambda ()
      (if (= step (- STEPS/MOVE 1))
          (begin (ball-update!)
                 (set! step 0))
          (set! step (+ step 1))))))

(define grid (make-array (shape 0 GRID-COLS 0 GRID-ROWS) EMPTY-NUM))

(define (grid-set! x y e)
  (array-set! grid x y e))

(define (grid-update!)
  ;; clear grid
  (do ((x 0 (+ x 1)))
      ((= x GRID-COLS))
    (do ((y 0 (+ y 1)))
        ((= y GRID-ROWS))
      (grid-set! x y EMPTY-NUM)))
  ;; add blocks
  (do ((x 0 (+ x 1)))
      ((= x GRID-COLS))
    (do ((y 0 (+ y 1)))
        ((= y GRID-ROWS))
      (when (array-ref blocks x y)
        (grid-set! x y BLOCK-NUM))))
  ;; add player
  (grid-set! (player-x) (player-y) PLAYER-NUM)
  (do ((r 1 (+ r 1)))
      ((> r PLAYER-RADIUS))
    (grid-set! (- (player-x) r) (player-y) PLAYER-NUM)
    (grid-set! (+ (player-x) r) (player-y) PLAYER-NUM))
  ;; add ball
  (grid-set! (ball-x) (ball-y) BALL-NUM))

(define (draw-walls)
  (define (refresh-sleep!)
    (refresh)
    (thread-sleep! SLEEP-DRAW))
  (define center-x (/ SCR-COLS 2))
  ;; draw horizontal bar
  (if (fixnum? center-x)
      (do ((r 0 (+ r 1)))
          ((= r (- center-x 1)))
        (mvaddch 0 (- center-x r 1) #\-)
        (mvaddch 0 (+ center-x r) #\-)
        (refresh-sleep!))
      (let ((cx (efloor center-x)))
        (mvaddch 0 cx #\-)
        (do ((r 1 (+ r 1)))
            ((= r cx))
          (mvaddch 0 (- cx r) #\-)
          (mvaddch 0 (+ cx r) #\-)
          (refresh-sleep!))))
  ;; draw corners
  (mvaddch 0 0 #\+)
  (mvaddch 0 (- SCR-COLS 1) #\+)
  (refresh-sleep!)
  ;; draw vertical bars
  (do ((y 1 (+ y 1)))
      ((= y SCR-ROWS))
    (mvaddch y 0 #\|)
    (mvaddch y (- SCR-COLS 1) #\|)
    (refresh-sleep!)))

(define (draw-grid)
  (define (cell->char x y)
    (define cell (array-ref grid x y))
    (cond ((= cell EMPTY-NUM)  EMPTY-CHAR)
          ((= cell PLAYER-NUM) PLAYER-CHAR)
          ((= cell BALL-NUM)   BALL-CHAR)
          ((= cell BLOCK-NUM)  BLOCK-CHAR)))
  (do ((x 0 (+ x 1)))
      ((= x GRID-COLS))
    (do ((y 0 (+ y 1)))
        ((= y GRID-ROWS))
      (mvaddch (+ y 1) (+ x 1) (cell->char x y))))
  (refresh))

(define (main)
  (initscr)
  (cbreak)
  (noecho)
  (curs_set 0)
  (keypad (stdscr) #t)
  (nodelay (stdscr) #t)
  (load-blocks! DEFAULT-BLOCKS)
  (grid-update!)
  (draw-walls)
  (draw-grid)
  (flushinp)
  (let loop ((key (getch)))
    (unless (char=? key KEY-QUIT)
      (cond ((zero? block-count) (end-game 'win))
            ((= (ball-y) (- GRID-ROWS 1)) (end-game 'loss))
            ((memv key KEY-LEFT) (player-move! -1))
            ((memv key KEY-RIGHT) (player-move! 1)))
      (flushinp)
      (ball-step!)
      (grid-update!)
      (draw-grid)
      (thread-sleep! SLEEP-LOOP)
      (loop (getch))))
  (endwin))

(with-exception-handler
    (lambda (exn)
      (endwin)
      (display "ascii-breaker: an error has occurred\n"))
  main)
